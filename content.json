{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Charles","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-05-06T05:49:20.000Z","updated":"2019-05-06T05:52:54.997Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"本文链接：&lt;%= post.title %&gt; 作者：charlesFeng 出处：http://fengjun2016.github.io/本文基于 知识共享署名-相同方式共享 4.0 国际许可协议发布，欢迎转载，演绎或用于商业目的，但是必须保留本文的署名charlesFeng及链接。"}],"posts":[{"title":"redis布隆选择器在去重方面的使用","slug":"redis布隆选择器在去重方面的使用","date":"2019-06-11T08:25:00.000Z","updated":"2019-06-11T09:16:38.213Z","comments":true,"path":"2019/06/11/redis布隆选择器在去重方面的使用/","link":"","permalink":"http://yoursite.com/2019/06/11/redis布隆选择器在去重方面的使用/","excerpt":"","text":"redis布隆选择器背景介绍: 1.使用场景：推荐系统给用户推荐新闻，避免重复推送。 需要考虑问题：从用户观看历史中筛选出没有看过的新闻进行推送，就需要数据库中频繁的使用exists进行查询，但是当用户量很大时，数据库很难顶住压力。 解决方法： 1.1.使用缓存？但是日子长了，会浪费很大空间，不是长久之计，不是很好的解决办法。 1.2.这时布隆过滤器就可以很好的解决这个需求了，可以节约90%以上的空间，缺点就是稍微有那么一点不准确，存在一定的误判率，但是对于这个新闻推送的可以忽略。 2.什么布隆过滤器 2.1其实布隆过滤器可以看成是一个不是很准确的set结构，只是在使用它的contains方法判断某个对象是否存在时会出现误判。但是它也不是特别的不精准，只要参数设置合理，那么它的精确度可以控制的足够精准，只会有小小的误判。 2.2当布隆过滤器说某个值存在时，那可能就不存在，如果说某个值不存在时，那肯定就是不存在了 打个比方，当一个人说认识你时可能不认识你，当一个人说不认识你时那肯定就不认识了。当它说见过你时，可能根本没有见过面，只不过可能你的脸和它所认识人中某个人的脸相似度比较高，所以产生误判。 2.3对于上面的场景，当用户看过的新闻，肯定会被过滤掉，对于没有看多的新闻，可能会过滤极少的一部分（误判），但是绝大部分都可以准确识别。这样可以完全保证推送给用户的新闻都是无重复的。 3.需要安装新版的redis版本 这里我们使用docker来安装redislabs/rebloom : docker pull redislabs/rebloom:latest 4.bloomfilter 命令使用 4.1 bf.add 语法:[bf.add key options]127.0.0.1&gt; bf.add users user3 (integer) 1 4.2 bf.exists 语法:[bf.exixts key options]127.0.0.1&gt; bf.exists users user3 (integer) 1 4.3 bf.madd 语法:[bf.madd key …options]127.0.0.1&gt; bf.madd users user4 user5 user6 user7 (integer) 1 (integer) 1 (integer) 1 (integer) 1 4.4 bf.mexists 语法:[bf.mexists key …options]127.0.0.1&gt; bf.mexists users user4 user5 user6 user7 user8 (integer) 1 (integer) 1 (integer) 1 (integer) 1 (integer) 0 4.5 bf.reserve 创建Filter 语法:[bf.reserve key error_rate initial_size]127.0.0.1&gt; bf.reserve books 0.001 10000 ok 5.在golang中的代码的具体实现和运用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import ( \"encoding/json\" \"fmt\" \"log\" \"github.com/gomodule/redigo/redis\")func (blog *Blog) AddUserLog(userId, blogId string) error &#123; cache := app.GetCache() defer cache.Close() _, err := cache.Do(\"BF.ADD\", \"user-read-log-\"+blogId, userId) if err != nil &#123; fmt.Println(\"bloom filer add err\", err) return err &#125; return nil&#125;func (blog *Blog) CheckIsRead(userId string, blogIds []string) ([]int, error) &#123; cache := app.GetCache() defer cache.Close() ints := []int&#123;&#125; for _, blogId := range blogIds &#123; args := []interface&#123;&#125;&#123;\"user-read-log-\" + blogId&#125; args = append(args, userId) intExists, err := redis.Int(cache.Do(\"bf.exists\", args...)) if err != nil &#123; fmt.Println(\"debug charles intExists error arg\", args) intExists = 1 &#125; ints = append(ints, intExists) &#125; return ints, nil&#125;func (blog *Blog) DeleteBlogLogCache(blogId string) error &#123; cache := app.GetCache() defer cache.Close() _, err := cache.Do(\"EXPIRE\", \"user-read-log-\"+blogId, 0) if err != nil &#123; fmt.Println(\"redis set expire bloom filter and err\", err) return err &#125; return nil&#125; 还有一点特别要注意的事项就是, bf只有add和exists两种类似的操作 没有删除操作 如果要是想删除改数据 则使用expire 使该key过期 例如上面演示代码里面提到的DeleteBlogCache函数的用法","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://yoursite.com/tags/redis/"}]},{"title":"gorm err不为空和记录未找到的错误区别","slug":"gorm err不为空和记录未找到","date":"2019-06-11T08:00:00.000Z","updated":"2019-06-11T08:15:34.347Z","comments":true,"path":"2019/06/11/gorm err不为空和记录未找到/","link":"","permalink":"http://yoursite.com/2019/06/11/gorm err不为空和记录未找到/","excerpt":"","text":"gorm 中err != nil 并不是真的服务器有错误 因为它会把记录未找到也当成是err 并且此时err != nil:对于查找的记录是单个结构体的话 所以我们在处理gorm给我返回的错误的时候 要特别处理一下 例如下面这种处理方式:123456err == gorm.ErrRecordNotFound &#123; // do something&#125;if err != nil &#123; // do something&#125; 对于查找的记录是结构体数组的时候 判断记录是否为空的时候 则要采取另外一种判断 因为没有记录 并不会报错: 此时我们就只需要判断给我们返回的结构体数组的长度是否是0 来判断是否有查找到记录的 特别要注意这两种情况的判断","categories":[],"tags":[{"name":"goalng gorm","slug":"goalng-gorm","permalink":"http://yoursite.com/tags/goalng-gorm/"}]},{"title":"本地新建仓库并关联远程仓库并且首次提交master分支","slug":"本地新建仓库关联远程仓库并首次提交master","date":"2019-06-11T07:45:45.000Z","updated":"2019-06-11T07:52:54.654Z","comments":true,"path":"2019/06/11/本地新建仓库关联远程仓库并首次提交master/","link":"","permalink":"http://yoursite.com/2019/06/11/本地新建仓库关联远程仓库并首次提交master/","excerpt":"","text":"会出现的问题 首次空的提交远程master分支报错: 处理方法: git commit -m “empty commit” –allow-empty 一般流程的情况是: 先配置信息 * git config --global user.name &quot;xxxxx&quot; * git config --global user.email &quot;xxxx@xx.com&quot; 创建仓库并提交代码 * git init * git remote add origin git@github.***.com:xxxx/***.git * git add -A * git commit -am&quot;首次建立项目提交&quot; * git push origin -u origin master","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"golang 逃逸分析","slug":"golang 逃逸分析","date":"2019-05-07T03:19:45.000Z","updated":"2019-05-07T03:36:26.094Z","comments":true,"path":"2019/05/07/golang 逃逸分析/","link":"","permalink":"http://yoursite.com/2019/05/07/golang 逃逸分析/","excerpt":"","text":"golang 逃逸分析什么叫做golang的逃逸分析 逃逸分析是确定指针动态范围的方法,可以分析在程序的哪些地方可以访问指针.当一个变量(或对象)在子程序中被分配,一个指向变量的指针可能逃逸到其他执行线程中,或者去调用子程序.如果使用尾递归优化,对象也可能逃逸到被调用的子程序中.如果一个程序分配一个对象并返回一个该对象的指针,该对象可能在程序中的任何一个地方被访问到,这样指针就成功逃逸了. 如果指针存储在全局变量或者其他数据结构中,也可能发生逃逸,这种情况是当前程序中的指针逃逸.逃逸分析需要确定指针所有可以存储的地方,保证指针的生命周期只在当前进程或线程中. 逃逸分析的好处 减少gc压力,不逃逸的对象分配在栈上,当函数返回时就回收了资源,不需要gc标记清楚 逃逸分析完以后可以确定哪些变量可以分配在栈上,栈的分配比堆快,性能更好 同步消除","categories":[],"tags":[{"name":"goalng","slug":"goalng","permalink":"http://yoursite.com/tags/goalng/"}]},{"title":"golang nsq实时消息处理系统源码解读一一基本介绍","slug":"golang nsq","date":"2019-05-06T07:42:45.000Z","updated":"2019-05-07T03:38:40.712Z","comments":true,"path":"2019/05/06/golang nsq/","link":"","permalink":"http://yoursite.com/2019/05/06/golang nsq/","excerpt":"","text":"关于golang中nsq实时消息处理系统的背景介绍 NSQ是由知名短链接服务商bitly用Go语言开发的实时消息处理系统，具有高性能、高可靠、无视单点故障等优点，是一个非常不错的新兴的消息队列解决方案; nsg易于配置和部署，所有参考都通过命令行指定，编译好的二进制文件，没有其它依赖项。而且支持多种消息格式。 源码下载地址 本系列文档下载的源码为0.2.27版本 为了更好的理解源码,最理想的起步当然是先了解nsq的用法, 所以接下来会先讲解nsq的安装和使用 nsq的安装 1.安装golang的环境 2.安装godep,在命令行执行: 1$ go get github.com/kr/godep 如果使用go get安装过程中报错,可以参考另一篇文章:关于go get安装git golang项目时报错的处理办法安装之后,在$GOPATH/bin目录下面就可以看到有godep 的可执行文件,记得讲$GOPATH/bin目录环境配置到系统环境变量$PATH里面,以后在命令行就可以直接输入godep命令来执行一些操作了. 3.安装assert,在命令行执行: 1$ go get github.com/bmizerany/assert 4.接下来开始获取nsq的代码并编译, 在命令行执行 1$ godep get github.com/bitly/nsq/... 注意: 后面有三个点不能少, 执行完之后在$GOPATH/bin目录下面就会看到有很多nsq打头的可执行二进制文件存在,至此安装就结束了","categories":[],"tags":[{"name":"goalng nsq","slug":"goalng-nsq","permalink":"http://yoursite.com/tags/goalng-nsq/"}]},{"title":"golang 中关于数组的相关特性","slug":"golang array","date":"2019-05-06T07:42:45.000Z","updated":"2019-05-06T07:42:59.584Z","comments":true,"path":"2019/05/06/golang array/","link":"","permalink":"http://yoursite.com/2019/05/06/golang array/","excerpt":"","text":"golang 中关于数组的相关特性 值类型 作为参数传递时 不能修改其值 只是一种拷贝 而且还需要特别注意的就是 不同长度的数组类型不一样 123456789101112131415package main import ( \"fmt\")func print(arr [3]int) &#123; arr[0] = 100&#125;func main() &#123; arr1 := [3]int&#123;1, 2, 3&#125; print(arr1)&#125;//结果打印出来的应该仍然还是1，2，3 如果想要改变的话 需要使用指针传递作为参数 但是常见的是使用 slice 切片 自动可以修改原来的数据 数组类型跟长度有关系 可以定义[…]int 让编译器自己去判断数组长度","categories":[],"tags":[{"name":"goalng","slug":"goalng","permalink":"http://yoursite.com/tags/goalng/"}]},{"title":"golang 字符串处理","slug":"golang string","date":"2019-05-06T07:41:45.000Z","updated":"2019-05-06T07:48:44.988Z","comments":true,"path":"2019/05/06/golang string/","link":"","permalink":"http://yoursite.com/2019/05/06/golang string/","excerpt":"","text":"字符和字符串处理相关常见操作 特别是对于中文字符的处理以及全球不同字符的处置golang中string实现的背景介绍 golang中string底层是通过byte数组实现的。中文字符在unicode下占2个字节，在utf-8编码下占3个字节，而golang默认编码正好是utf-8。 关于golang中的rune:// rune is an alias for int32 and is equivalent to int32 in all ways. It is// used, by convention, to distinguish character values from integer values. //int32的别名，几乎在所有方面等同于int32//它用来区分字符值和整数值 type rune = int32 获取字节数长度 len 特别记住这一点 len(s)返回的是底层的字节数 英文占一个字节 中文字符在golang中占有两个字节 并不是获得字符串长度 关于utf-8和rune的互相转换 关于含有中文字符串的对于每一个中文字符的遍历处理 强制转换该字符串变成一个[]rune数组 计算字节数 使用range遍历pos, rune pos会不连续 使用[]byte转换获得字节 使用utf8.RuneCountInStriung获得字符数量 golang中海油一个byte数据类型与rune相似，它们都是用来表示字符类型的变量类型。它们的不同在于： byte 等同于int8，常用来处理ascii字符 rune 等同于int32,常用来处理unicode或utf-8字符 12345678910111213141516171819202122232425262728293031323334353637383940414243package main import ( \"fmt\" \"unicode/utf8\")func main() &#123; s := \"Yes我爱慕课网!\" //UTF-8编码方式 中文 可变长编码方式 英文是一字节方式 中文是3字节方式存储 fmt.Println(s) //查看字符的具体存储 X打出字节的具体数字 16进制 每个字符的ascii码值 for _, b := range []byte(s) &#123; //utf-8编码 fmt.Println(\"%X\\n\", b) &#125; fmt.Println() for i, ch := range s &#123; //unicode编码 i是每个字符的开始字节数 ch is a rune(int32) 一个四字节的整数 fmt.Printf(\"(%d %X)\", i , ch) &#125; fmt.Println() fmt.Println(\"Rune count:\", utf8.RuneCountInString(s)) //获取rune个数 也是获取字符串长度的方法之一 //常用方法 for i, ch := range []rune(s) &#123; //获得一个rune数组 一个下标一个英文字符或者一个中文字符 获取字符串长度方法二 fmt.Println(\"(%d %c\"), i, ch) &#125; fmt.Println() bytes := []bytes(s) // for len(bytes) &gt; 0 &#123; ch, size := utf8.DecodeRune(bytes) fmt.Printf(\"(%c %v)\", ch, size) bytes = bytes[size:] &#125;&#125;运行结果:Yes我爱慕课网!59 65 73 E6 88 91 E7 88 B1 E6 85 95 E8 AF BE E7 BD 91 21 //utf-8编码(0 59)(1 65)(2 73)(3 6211)(6 7231)(9 6155)(12 8BFE)(15 7F51)(18 21) //unicode编码(0 Y)(1 e)(2 s)(3 我)(4 爱)(5 慕)(6 课)(7 网)(8 !) //第几个字符是谁(Y 1)(e 1)(s 1)(我 3)(爱 3)(慕 3)(课 3)(网 3)(! 1) 1234567891011121314151617181920212223242526package mainimport ( \"fmt\" \"unicode/utf8\")func main() &#123; var str = \"hello 你好\" //golang中string底层是通过byte数组实现的，座椅直接求len 实际是在按字节长度计算 所以一个汉字占3个字节算了3个长度 fmt.Println(\"len(str):\", len(str)) //以下两种都可以得到str的字符串长度 //golang中的unicode/utf8包提供了用utf-8获取长度的方法 fmt.Println(\"RuneCountInString:\", utf8.RuneCountInString(str)) //通过rune类型处理unicode字符 fmt.Println(\"rune:\", len([]rune(str)))&#125;运行结果:len(str): 12RuneCountInString: 8rune: 8","categories":[],"tags":[{"name":"goalng","slug":"goalng","permalink":"http://yoursite.com/tags/goalng/"}]},{"title":"etcd在mac系统中的安装与使用","slug":"golang mac etcd安装与使用","date":"2019-05-06T07:41:45.000Z","updated":"2019-05-06T07:50:25.395Z","comments":true,"path":"2019/05/06/golang mac etcd安装与使用/","link":"","permalink":"http://yoursite.com/2019/05/06/golang mac etcd安装与使用/","excerpt":"","text":"etcd在mac系统中的安装与使用 进入etcd官网提供的连接， 点击GitHub Project, 然后选择release版本下载编译好的版本代码包 解压下载好的代码包 cd 进入解压后的代码包 启动server端 nohup ./etcd –listen-client-urls ‘http://0.0.0.0:2379&#39; –advertise-client-urls ‘http://0.0.0.0:2379&#39; &amp; client客户端连接使用 ETCDCTL_API=3 ./etcdctl put “name” “fengjun” ETCDCTL_API=3 ./etcdctl get “name” etcd特性总结 对于key前缀相同的有序排列存储在系统中 例如: ETCDCTL_API=3 ./etcdctl put “/cron/jobs/job1” “{…job1}” ETCDCTL_API=3 ./etcdctl put “/cron/jobs/job2” “{…job2}” 然后可以按照key前缀设置来查找集合 ETCDCTL_API=3 ./etcdctl get “/cron/jobs/“ –prefix /cron/jobs/job1 {…job1} /cron/jobs/job2 {…job2} 在新开的终端会话界面使用watch命令检测 进入解压后的文件夹中 ETCDCTL_API=3 ./etcdctl watch “/cron/jobs/“ –prefix ETCDCTL_API=3 ./etcdctl put “/cron/jobs/job2” “{…1111}” //修改 新开的终端会显示:PUT/cron/jobs/job2{…1111} 获取etcd golang客户端的代码 在上面打开的etcdgithub项目代码里面 clientv3 etcd/clientv3 is the official Go etcd client for v3. golang安装客户端代码方式 Install go get github.com/coreos/etcd/client //或者使用gopm工具 或者进入golang中国下载该包 然后入项目中","categories":[],"tags":[{"name":"goalng etcd mac","slug":"goalng-etcd-mac","permalink":"http://yoursite.com/tags/goalng-etcd-mac/"}]},{"title":"golang字符串时间戳转换成time.Time类型","slug":"golang字符串时间戳转换成time.Time类型","date":"2019-05-06T07:09:45.000Z","updated":"2019-05-06T07:21:05.302Z","comments":true,"path":"2019/05/06/golang字符串时间戳转换成time.Time类型/","link":"","permalink":"http://yoursite.com/2019/05/06/golang字符串时间戳转换成time.Time类型/","excerpt":"","text":"时间转换的原理是: 将原先的字符串时间戳转换为int64位, 再使用time.Unix(v, 0)转换成time类型的时间戳 需要相关使用的函数有: unix64, _ := strconv.ParseInt(unixStr, 10, 64) time.Unix(v, 0) 代码示例:123var startTime time.TimestartTimeInt64, _ := strconv.ParseInt(start, 10, 64)startTime = time.Unix(startTimeInt64, 0)","categories":[],"tags":[{"name":"goalng","slug":"goalng","permalink":"http://yoursite.com/tags/goalng/"}]},{"title":"golang字符串处理","slug":"golang字符串处理","date":"2019-05-06T06:12:01.000Z","updated":"2019-05-06T07:21:49.157Z","comments":true,"path":"2019/05/06/golang字符串处理/","link":"","permalink":"http://yoursite.com/2019/05/06/golang字符串处理/","excerpt":"","text":"关于golang中字符串处理相关注意事项 len(str) 获得是该字符串的字节数中文字符占3个字节 英文字母占一个字节如果想要获得数组 一个下标一个中文字符或者英文字符的话,需要使用[]rune()来强制转换","categories":[],"tags":[{"name":"goalng","slug":"goalng","permalink":"http://yoursite.com/tags/goalng/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-05-06T05:10:58.498Z","updated":"2019-05-06T05:10:58.498Z","comments":true,"path":"2019/05/06/hello-world/","link":"","permalink":"http://yoursite.com/2019/05/06/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}