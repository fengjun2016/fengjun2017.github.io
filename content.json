{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Charles","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-05-06T05:49:20.000Z","updated":"2019-05-06T05:52:54.997Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"本文链接：&lt;%= post.title %&gt; 作者：charlesFeng 出处：http://fengjun2016.github.io/本文基于 知识共享署名-相同方式共享 4.0 国际许可协议发布，欢迎转载，演绎或用于商业目的，但是必须保留本文的署名charlesFeng及链接。"}],"posts":[{"title":"golang 逃逸分析","slug":"golang 逃逸分析","date":"2019-05-07T03:19:45.000Z","updated":"2019-05-07T03:36:26.094Z","comments":true,"path":"2019/05/07/golang 逃逸分析/","link":"","permalink":"http://yoursite.com/2019/05/07/golang 逃逸分析/","excerpt":"","text":"golang 逃逸分析什么叫做golang的逃逸分析 逃逸分析是确定指针动态范围的方法,可以分析在程序的哪些地方可以访问指针.当一个变量(或对象)在子程序中被分配,一个指向变量的指针可能逃逸到其他执行线程中,或者去调用子程序.如果使用尾递归优化,对象也可能逃逸到被调用的子程序中.如果一个程序分配一个对象并返回一个该对象的指针,该对象可能在程序中的任何一个地方被访问到,这样指针就成功逃逸了. 如果指针存储在全局变量或者其他数据结构中,也可能发生逃逸,这种情况是当前程序中的指针逃逸.逃逸分析需要确定指针所有可以存储的地方,保证指针的生命周期只在当前进程或线程中. 逃逸分析的好处 减少gc压力,不逃逸的对象分配在栈上,当函数返回时就回收了资源,不需要gc标记清楚 逃逸分析完以后可以确定哪些变量可以分配在栈上,栈的分配比堆快,性能更好 同步消除","categories":[],"tags":[{"name":"goalng","slug":"goalng","permalink":"http://yoursite.com/tags/goalng/"}]},{"title":"golang 中关于数组的相关特性","slug":"golang array","date":"2019-05-06T07:42:45.000Z","updated":"2019-05-06T07:42:59.584Z","comments":true,"path":"2019/05/06/golang array/","link":"","permalink":"http://yoursite.com/2019/05/06/golang array/","excerpt":"","text":"golang 中关于数组的相关特性 值类型 作为参数传递时 不能修改其值 只是一种拷贝 而且还需要特别注意的就是 不同长度的数组类型不一样 123456789101112131415package main import ( \"fmt\")func print(arr [3]int) &#123; arr[0] = 100&#125;func main() &#123; arr1 := [3]int&#123;1, 2, 3&#125; print(arr1)&#125;//结果打印出来的应该仍然还是1，2，3 如果想要改变的话 需要使用指针传递作为参数 但是常见的是使用 slice 切片 自动可以修改原来的数据 数组类型跟长度有关系 可以定义[…]int 让编译器自己去判断数组长度","categories":[],"tags":[{"name":"goalng","slug":"goalng","permalink":"http://yoursite.com/tags/goalng/"}]},{"title":"golang nsq实时消息处理系统源码解读一一基本介绍","slug":"golang nsq","date":"2019-05-06T07:42:45.000Z","updated":"2019-05-06T08:02:59.348Z","comments":true,"path":"2019/05/06/golang nsq/","link":"","permalink":"http://yoursite.com/2019/05/06/golang nsq/","excerpt":"","text":"关于golang中nsq实时消息处理系统的背景介绍 NSQ是由知名短链接服务商bitly用Go语言开发的实时消息处理系统，具有高性能、高可靠、无视单点故障等优点，是一个非常不错的新兴的消息队列解决方案; nsg易于配置和部署，所有参考都通过命令行指定，编译好的二进制文件，没有其它依赖项。而且支持多种消息格式。 源码下载地址","categories":[],"tags":[{"name":"goalng nsq","slug":"goalng-nsq","permalink":"http://yoursite.com/tags/goalng-nsq/"}]},{"title":"etcd在mac系统中的安装与使用","slug":"golang mac etcd安装与使用","date":"2019-05-06T07:41:45.000Z","updated":"2019-05-06T07:50:25.395Z","comments":true,"path":"2019/05/06/golang mac etcd安装与使用/","link":"","permalink":"http://yoursite.com/2019/05/06/golang mac etcd安装与使用/","excerpt":"","text":"etcd在mac系统中的安装与使用 进入etcd官网提供的连接， 点击GitHub Project, 然后选择release版本下载编译好的版本代码包 解压下载好的代码包 cd 进入解压后的代码包 启动server端 nohup ./etcd –listen-client-urls ‘http://0.0.0.0:2379&#39; –advertise-client-urls ‘http://0.0.0.0:2379&#39; &amp; client客户端连接使用 ETCDCTL_API=3 ./etcdctl put “name” “fengjun” ETCDCTL_API=3 ./etcdctl get “name” etcd特性总结 对于key前缀相同的有序排列存储在系统中 例如: ETCDCTL_API=3 ./etcdctl put “/cron/jobs/job1” “{…job1}” ETCDCTL_API=3 ./etcdctl put “/cron/jobs/job2” “{…job2}” 然后可以按照key前缀设置来查找集合 ETCDCTL_API=3 ./etcdctl get “/cron/jobs/“ –prefix /cron/jobs/job1 {…job1} /cron/jobs/job2 {…job2} 在新开的终端会话界面使用watch命令检测 进入解压后的文件夹中 ETCDCTL_API=3 ./etcdctl watch “/cron/jobs/“ –prefix ETCDCTL_API=3 ./etcdctl put “/cron/jobs/job2” “{…1111}” //修改 新开的终端会显示:PUT/cron/jobs/job2{…1111} 获取etcd golang客户端的代码 在上面打开的etcdgithub项目代码里面 clientv3 etcd/clientv3 is the official Go etcd client for v3. golang安装客户端代码方式 Install go get github.com/coreos/etcd/client //或者使用gopm工具 或者进入golang中国下载该包 然后入项目中","categories":[],"tags":[{"name":"goalng etcd mac","slug":"goalng-etcd-mac","permalink":"http://yoursite.com/tags/goalng-etcd-mac/"}]},{"title":"golang 字符串处理","slug":"golang string","date":"2019-05-06T07:41:45.000Z","updated":"2019-05-06T07:48:44.988Z","comments":true,"path":"2019/05/06/golang string/","link":"","permalink":"http://yoursite.com/2019/05/06/golang string/","excerpt":"","text":"字符和字符串处理相关常见操作 特别是对于中文字符的处理以及全球不同字符的处置golang中string实现的背景介绍 golang中string底层是通过byte数组实现的。中文字符在unicode下占2个字节，在utf-8编码下占3个字节，而golang默认编码正好是utf-8。 关于golang中的rune:// rune is an alias for int32 and is equivalent to int32 in all ways. It is// used, by convention, to distinguish character values from integer values. //int32的别名，几乎在所有方面等同于int32//它用来区分字符值和整数值 type rune = int32 获取字节数长度 len 特别记住这一点 len(s)返回的是底层的字节数 英文占一个字节 中文字符在golang中占有两个字节 并不是获得字符串长度 关于utf-8和rune的互相转换 关于含有中文字符串的对于每一个中文字符的遍历处理 强制转换该字符串变成一个[]rune数组 计算字节数 使用range遍历pos, rune pos会不连续 使用[]byte转换获得字节 使用utf8.RuneCountInStriung获得字符数量 golang中海油一个byte数据类型与rune相似，它们都是用来表示字符类型的变量类型。它们的不同在于： byte 等同于int8，常用来处理ascii字符 rune 等同于int32,常用来处理unicode或utf-8字符 12345678910111213141516171819202122232425262728293031323334353637383940414243package main import ( \"fmt\" \"unicode/utf8\")func main() &#123; s := \"Yes我爱慕课网!\" //UTF-8编码方式 中文 可变长编码方式 英文是一字节方式 中文是3字节方式存储 fmt.Println(s) //查看字符的具体存储 X打出字节的具体数字 16进制 每个字符的ascii码值 for _, b := range []byte(s) &#123; //utf-8编码 fmt.Println(\"%X\\n\", b) &#125; fmt.Println() for i, ch := range s &#123; //unicode编码 i是每个字符的开始字节数 ch is a rune(int32) 一个四字节的整数 fmt.Printf(\"(%d %X)\", i , ch) &#125; fmt.Println() fmt.Println(\"Rune count:\", utf8.RuneCountInString(s)) //获取rune个数 也是获取字符串长度的方法之一 //常用方法 for i, ch := range []rune(s) &#123; //获得一个rune数组 一个下标一个英文字符或者一个中文字符 获取字符串长度方法二 fmt.Println(\"(%d %c\"), i, ch) &#125; fmt.Println() bytes := []bytes(s) // for len(bytes) &gt; 0 &#123; ch, size := utf8.DecodeRune(bytes) fmt.Printf(\"(%c %v)\", ch, size) bytes = bytes[size:] &#125;&#125;运行结果:Yes我爱慕课网!59 65 73 E6 88 91 E7 88 B1 E6 85 95 E8 AF BE E7 BD 91 21 //utf-8编码(0 59)(1 65)(2 73)(3 6211)(6 7231)(9 6155)(12 8BFE)(15 7F51)(18 21) //unicode编码(0 Y)(1 e)(2 s)(3 我)(4 爱)(5 慕)(6 课)(7 网)(8 !) //第几个字符是谁(Y 1)(e 1)(s 1)(我 3)(爱 3)(慕 3)(课 3)(网 3)(! 1) 1234567891011121314151617181920212223242526package mainimport ( \"fmt\" \"unicode/utf8\")func main() &#123; var str = \"hello 你好\" //golang中string底层是通过byte数组实现的，座椅直接求len 实际是在按字节长度计算 所以一个汉字占3个字节算了3个长度 fmt.Println(\"len(str):\", len(str)) //以下两种都可以得到str的字符串长度 //golang中的unicode/utf8包提供了用utf-8获取长度的方法 fmt.Println(\"RuneCountInString:\", utf8.RuneCountInString(str)) //通过rune类型处理unicode字符 fmt.Println(\"rune:\", len([]rune(str)))&#125;运行结果:len(str): 12RuneCountInString: 8rune: 8","categories":[],"tags":[{"name":"goalng","slug":"goalng","permalink":"http://yoursite.com/tags/goalng/"}]},{"title":"golang字符串时间戳转换成time.Time类型","slug":"golang字符串时间戳转换成time.Time类型","date":"2019-05-06T07:09:45.000Z","updated":"2019-05-06T07:21:05.302Z","comments":true,"path":"2019/05/06/golang字符串时间戳转换成time.Time类型/","link":"","permalink":"http://yoursite.com/2019/05/06/golang字符串时间戳转换成time.Time类型/","excerpt":"","text":"时间转换的原理是: 将原先的字符串时间戳转换为int64位, 再使用time.Unix(v, 0)转换成time类型的时间戳 需要相关使用的函数有: unix64, _ := strconv.ParseInt(unixStr, 10, 64) time.Unix(v, 0) 代码示例:123var startTime time.TimestartTimeInt64, _ := strconv.ParseInt(start, 10, 64)startTime = time.Unix(startTimeInt64, 0)","categories":[],"tags":[{"name":"goalng","slug":"goalng","permalink":"http://yoursite.com/tags/goalng/"}]},{"title":"golang字符串处理","slug":"golang字符串处理","date":"2019-05-06T06:12:01.000Z","updated":"2019-05-06T07:21:49.157Z","comments":true,"path":"2019/05/06/golang字符串处理/","link":"","permalink":"http://yoursite.com/2019/05/06/golang字符串处理/","excerpt":"","text":"关于golang中字符串处理相关注意事项 len(str) 获得是该字符串的字节数中文字符占3个字节 英文字母占一个字节如果想要获得数组 一个下标一个中文字符或者英文字符的话,需要使用[]rune()来强制转换","categories":[],"tags":[{"name":"goalng","slug":"goalng","permalink":"http://yoursite.com/tags/goalng/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-05-06T05:10:58.498Z","updated":"2019-05-06T05:10:58.498Z","comments":true,"path":"2019/05/06/hello-world/","link":"","permalink":"http://yoursite.com/2019/05/06/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}